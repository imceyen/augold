<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>AuGold 관리자 페이지</title>
  <style>
    body { margin: 0; font-family: 'Segoe UI', sans-serif; }
    header {
        background-color: #343a40;
        color: white;
        padding: 15px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .tab-bar {
        background-color: #f8f9fa;
        display: flex;
        border-bottom: 1px solid #dee2e6;
    }
    .tab-bar button {
        flex: 1;
        padding: 15px;
        font-size: 16px;
        border: none;
        background-color: #f8f9fa;
        cursor: pointer;
    }
    .tab-bar button.active {
        background-color: white;
        border-bottom: 3px solid goldenrod;
        font-weight: bold;
    }
    .content {
        padding: 30px;
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* 통계 하위 탭 스타일 */
    .stats-subtab-bar {
        margin-bottom: 20px;
        display: flex;
        border-bottom: 1px solid #ccc;
    }
    .stats-subtab-bar button {
        padding: 10px 15px;
        border: none;
        background-color: #eee;
        cursor: pointer;
        margin-right: 5px;
        font-size: 14px;
    }
    .stats-subtab-bar button.active {
        background-color: white;
        border-bottom: 3px solid goldenrod;
        font-weight: bold;
    }

    .stats-subtab-content {
        display: none;
    }
    .stats-subtab-content.active {
        display: block;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        margin-top: 20px;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: center;
    }
    th {
        background-color: #f2f2f2;
    }
    .form-container {
        margin-top: 30px;
        border: 1px solid #ccc;
        padding: 20px;
    }
    .form-container input, .form-container select {
        padding: 8px;
        margin: 5px 0;
        width: 100%;
    }
    .form-container button {
        margin-top: 10px;
        padding: 10px 20px;
        background-color: goldenrod;
        border: none;
        color: white;
        cursor: pointer;
    }
    .form-container .delete-btn {
        background-color: #dc3545;
        margin-left: 10px;
    }
  </style>
</head>
<body>

<header>
  <h2>관리자 페이지</h2>
  <div>AuGold Admin</div>
</header>

<div class="tab-bar">
  <button class="tab-btn active" onclick="showTab('productTab', event)">상품 관리</button>
  <button class="tab-btn" onclick="showTab('statsTab', event)">통계</button>
  <button class="tab-btn" onclick="showTab('receiptTab', event)">영수증 등록</button>
  <button class="tab-btn" onclick="showTab('inquiryTab', event)">문의 답변</button>
</div>

<div class="content">
  <!-- 상품 관리 -->
  <div id="productTab" class="tab-content active">
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <h3>상품 관리</h3>
      <button onclick="toggleForm()">상품 등록</button>
    </div>

    <div class="form-container" id="productForm" style="display:none;">
      <form onsubmit="submitProduct(event)" enctype="multipart/form-data">
        <label>상품 ID:
          <input type="text" name="productId" readonly>
        </label><br><br>
        <label>상품명:
          <input type="text" name="productName" required>
        </label><br><br>
        <label>카테고리:
          <select name="ctgrId" required>
            <option value="">선택</option>
            <option value="0001">0001 [주얼리]</option>
            <option value="0002">0002 [골드바]</option>
            <option value="0003">0003 [기념품]</option>
          </select>
        </label><br><br>
        <label>서브 카테고리:
          <select name="subCtgr" required>
            <option value="">선택</option>
            <option value="귀걸이">귀걸이</option>
            <option value="반지">반지</option>
            <option value="목걸이">목걸이</option>
            <option value="골드바">골드바</option>
            <option value="감사패">감사패</option>
            <option value="돌반지">돌반지</option>
            <option value="카네이션 기념품">카네이션 기념품</option>
          </select>
        </label><br><br>
        <label>금 함량:
          <select name="karatCode" required>
            <option value="">선택</option>
            <option value="14K">14K</option>
            <option value="18K">18K</option>
            <option value="24K">24K</option>
          </select>
        </label><br><br>
        <label>금 무게 (g):
          <input type="number" name="goldWeight" step="0.01" required>
        </label><br><br>
        <label>원가:
          <input type="number" name="basePrice" step="0.01" required>
        </label><br><br>
        <label>판매가:
          <input type="number" name="finalPrice" step="0.01" required>
        </label><br><br>
        <label>상품 설명:
          <input type="text" name="description">
        </label><br><br>
        <label>대표 이미지:
          <input type="file" name="imageFile" accept="image/*" required>
        </label><br><br>
        <label>상세 이미지 (최대 3장):
          <input type="file" name="detailImages" accept="image/*" multiple>
        </label><br><br>
        <button type="submit">상품 저장</button>
        <button type="button" class="delete-btn" onclick="deleteProduct()" style="display: none;">상품 삭제</button>
      </form>
    </div>

    <table id="productTable">
      <thead>
      <tr>
        <th>ID</th><th>이름</th><th>금 함량</th><th>카테고리</th><th>가격</th><th>무게</th><th>최종가</th><th>서브</th>
      </tr>
      </thead>
      <tbody>
      <!-- JS로 상품목록 추가 -->
      </tbody>
    </table>
  </div>

  <!-- 통계 탭 -->
  <div id="statsTab" class="tab-content">
    <h3>통계 분석</h3>

    <!-- 통계 하위 탭 버튼 -->
    <div class="stats-subtab-bar">
      <button class="stats-subtab-btn" onclick="showStatsSubTab('salesAnalysis', event)">매출 분석 및 예측</button>
      <button class="stats-subtab-btn active" onclick="showStatsSubTab('goldPrice', event)">금 시세 분석 및 예측</button>
      <button class="stats-subtab-btn" onclick="showStatsSubTab('demographics', event)">성별/연령대별 매출/구매패턴 분석</button>
      <button class="stats-subtab-btn" onclick="showStatsSubTab('orderTrends', event)">판매날짜 기반 주문 트렌드 분석</button>
      <button class="stats-subtab-btn" onclick="showStatsSubTab('categoryProfit', event)">카테고리별 이익률 분석/예측</button>
    </div>

    <!-- 하위 탭 컨텐츠 -->
    <div id="salesAnalysis" class="stats-subtab-content">
      <p>매출 분석 및 예측 데이터를 보여주는 영역입니다. (추후 구현 예정)</p>
    </div>

    <div id="goldPrice" class="stats-subtab-content active">
      <!-- Plotly.js CDN 추가 -->
      <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

      <div id="loadingMessage" style="text-align: center; padding: 50px; font-size: 1.2em;">
        데이터를 불러오는 중입니다...
      </div>
      <div id="forecastPlot" class="plot-container" style="width: 90%; max-width: 900px; margin: 20px auto; display: none;"></div>
      <div id="trendPlot" class="plot-container" style="width: 90%; max-width: 900px; margin: 20px auto; display: none;"></div>
      <div id="weeklyPlot" class="plot-container" style="width: 90%; max-width: 900px; margin: 20px auto; display: none;"></div>
    </div>

    <!-- 📊 성별·연령대별 매출 차트 영역 -->
    <div id="demographics" class="stats-subtab-content">
      <p>성별 및 연령대별 매출 분석 시각화 결과입니다.</p>
      <div id="sexAgeLoading" style="text-align: center; padding: 40px; font-size: 1.1em;">
        데이터를 불러오는 중입니다...
      </div>
      <!-- ✅ 이곳에 Plotly 차트가 출력됩니다 -->
      <div style="display: flex; gap: 30px; justify-content: center;">
        <div id="genderAgeChartPlotMale" style="flex:1; min-width:350px; max-width:600px;"></div>
        <div id="genderAgeChartPlotFemale" style="flex:1; min-width:350px; max-width:600px;"></div>
      </div>
    </div>


    <div id="orderTrends" class="stats-subtab-content active">
      <div id="orderTrendsLoading" style="text-align: center; padding: 50px; font-size: 1.2em;">
        데이터를 불러오는 중입니다...
      </div>
      <div id="salesForecastPlot" class="plot-container" style="width: 90%; max-width: 1000px; margin: 20px auto; display: none;"></div>
      <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
        <div id="salesWeeklyPlot" class="plot-container" style="width: 90%; max-width: 480px; margin: 20px auto; display: none;"></div>
        <div id="salesYearlyPlot" class="plot-container" style="width: 90%; max-width: 480px; margin: 20px auto; display: none;"></div>
      </div>
    </div>

    <div id="categoryProfit" class="stats-subtab-content">
      <p>카테고리별 이익률 분석 및 예측 데이터를 보여주는 영역입니다.</p>
      <!-- 🔽 로딩 메시지 -->
      <div id="categoryProfitLoading" style="text-align: center; padding: 50px; font-size: 1.2em;">
        데이터를 불러오는 중입니다...
      </div>
      <!-- 🔽 Plotly 그래프 -->
      <div id="categoryProfitPlot" class="plot-container" style="width: 90%; max-width: 900px; margin: 20px auto; display: none;"></div>
    </div>


    <div id="receiptTab" class="tab-content">
    <h3>영수증 등록</h3>
    <form id="receiptForm" enctype="multipart/form-data" onsubmit="uploadReceipt(event)">
      <h4>영수증 이미지 업로드</h4>
      <input type="file" name="receiptImage" accept="image/*" required><br><br>
      <button type="submit">업로드</button>
    </form>

    <div id="ocrResult" style="margin-top: 20px;"></div>
  </div>

  <div id="inquiryTab" class="tab-content active">
    <h3>문의 답변</h3>

    <table id="inquiryTable">
      <thead>
      <tr>
        <th>#</th>
        <th>회원번호</th>
        <th>제목</th>
        <th>처리상태</th>
        <th>문의일시</th>
      </tr>
      </thead>
      <tbody>
      <!-- JS가 이 영역을 채웁니다 -->
      </tbody>
    </table>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      fetchInquiries();
    });

    /**
     * 문의 목록을 서버에서 가져와 표에 채운다
     */
    function fetchInquiries() {
      fetch('/api/inquiries')
        .then(res => {
          if (!res.ok) throw new Error("문의 목록을 불러오지 못했습니다.");
          return res.json();
        })
        .then(data => {
          const tbody = document.querySelector("#inquiryTable tbody");
          tbody.innerHTML = "";  // 기존 내용 초기화

          data.forEach((inq, index) => {
            const row = `
              <tr>
                <td>${index + 1}</td>
                <td>${inq.cstmNumber}</td>
                <td>
                 <a href="/admin/inquiry/${inq.inqNumber}">${inq.inqTitle}</a>
                </td>
                <td>${inq.inqStatus}</td>
                <td>${new Date(inq.inqDate).toLocaleString()}</td>
              </tr>
            `;
            tbody.insertAdjacentHTML("beforeend", row);
          });
        })
        .catch(err => {
          console.error(err);
          alert(err.message);
        });
    }
  </script>

</div>

<script>
  // 상품 관리 관련 변수 및 함수
  let editing = false;
  let editProductId = null;

  function toggleForm(show = null) {
      const form = document.getElementById('productForm');
      form.style.display = (show === true || (show === null && form.style.display === 'none')) ? 'block' : 'none';
  }

  // 페이지 로드 시 실행될 함수들
  document.addEventListener('DOMContentLoaded', () => {
      // 상품 관리 초기화
      document.querySelector('select[name="subCtgr"]').addEventListener("change", function () {
          const subCtgr = this.value;
          if (!subCtgr || editing) return;

          fetch(`/api/products/next-id?subCtgr=${encodeURIComponent(subCtgr)}`)
              .then(res => res.text())
              .then(productId => {
                  document.querySelector('#productForm input[name="productId"]').value = productId;
              });
      });
      fetchProducts();

      // 기본 탭 설정 (여기서는 상품 관리 탭이 기본으로 활성화됨)
      // 만약 다른 탭을 기본으로 하고 싶다면 이 부분을 수정할 수 있습니다.
  });

  function fetchProducts() {
      fetch('/api/products')
          .then(res => res.json())
          .then(data => {
              const tbody = document.querySelector("#productTable tbody");
              tbody.innerHTML = "";
              data.forEach(p => {
                  const row = `<tr>
                      <td>${p.productId}</td>
                      <td><a href="#" onclick="editProduct('${p.productId}')">${p.productName}</a></td>
                      <td>${p.karatCode}</td>
                      <td>${p.ctgrId}</td>
                      <td>${p.basePrice}</td>
                      <td>${p.goldWeight}</td>
                      <td>${p.finalPrice}</td>
                      <td>${p.subCtgr}</td>
                  </tr>`;
                  tbody.insertAdjacentHTML("beforeend", row);
              });
          });
  }

  function editProduct(id) {
    fetch(`/api/products/${id}`)
        .then(res => res.json())
        .then(p => {
            const form = document.querySelector('#productForm form');
            form.productId.value = p.productId;
            form.productName.value = p.productName;
            form.ctgrId.value = p.ctgrId;
            form.subCtgr.value = p.subCtgr;
            form.karatCode.value = p.karatCode;
            form.goldWeight.value = p.goldWeight;
            form.basePrice.value = p.basePrice;
            form.finalPrice.value = p.finalPrice;
            form.description.value = p.description;

            editProductId = id;
            editing = true;
            toggleForm(true);
            form.querySelector("button[type='submit']").innerText = "상품 수정";
            form.querySelector(".delete-btn").style.display = "inline-block";
        });
  }

  function submitProduct(event) {
    event.preventDefault();
    const form = event.target;
    const formData = new FormData(form);
    const method = editing ? 'PUT' : 'POST';
    const url = editing ? `/api/products/${editProductId}` : '/api/products';

    fetch(url, { method: method, body: formData })
      .then(res => {
        if (res.ok) {
            alert(editing ? "수정 완료!" : "상품이 등록되었습니다!");
            form.reset();
            toggleForm(false);
            fetchProducts();
            editing = false;
            editProductId = null;
            form.querySelector("button[type='submit']").innerText = "상품 저장";
            form.querySelector(".delete-btn").style.display = "none";
        } else {
            alert("저장 실패");
        }
    });
  }

  function deleteProduct() {
      if (!editProductId) return;
      if (!confirm("정말로 삭제하시겠습니까?")) return;

      fetch(`/api/products/${editProductId}`, { method: 'DELETE' })
        .then(res => {
          if (res.ok) {
              alert("삭제 완료!");
              const form = document.querySelector('#productForm form');
              form.reset();
              toggleForm(false);
              fetchProducts();
              editing = false;
              editProductId = null;
              form.querySelector("button[type='submit']").innerText = "상품 저장";
              form.querySelector(".delete-btn").style.display = "none";
          } else {
              alert("삭제 실패");
          }
      });
  }

  // 문의 관리 함수
  // 영수증 관리 함수
  function uploadReceipt(event) {
      event.preventDefault();
      const form = document.getElementById("receiptForm");
      const formData = new FormData(form);

      fetch('/api/receipt/upload', { method: 'POST', body: formData })
      .then(res => res.json())
      .then(data => {
          document.getElementById("ocrResult").innerText = "📄 OCR 결과:\n" + data.text;
      })
      .catch(err => {
          alert("업로드 실패");
          console.error(err);
      });
  }

  // --- 탭 및 통계 관련 로직 ---

  // 각 통계 탭의 데이터 로드 여부를 추적하는 플래그
  let goldPriceStatsLoaded = false;
  let orderTrendsLoaded = false;
  let categoryProfitLoaded = false;
  let demographicsLoaded = false;

  /**
   * 메인 탭 전환 함수
   */
  function showTab(tabId, event) {
      // 모든 탭 컨텐츠와 버튼 비활성화
      document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));

      // 클릭된 탭과 버튼 활성화
      document.getElementById(tabId).classList.add('active');
      event.currentTarget.classList.add('active');

      // '통계' 탭을 처음 열 때 기본 하위 탭 로직 실행
      if (tabId === 'statsTab') {
          // '판매날짜 기반 주문 트렌드 분석'을 기본 하위 탭으로 설정
          const defaultSubTabButton = document.querySelector('.stats-subtab-btn[onclick*="orderTrends"]');
          if (defaultSubTabButton && !defaultSubTabButton.classList.contains('active')) {
              showStatsSubTab('orderTrends', { currentTarget: defaultSubTabButton });
          }
      }
  }

  /**
   * 통계 하위 탭 전환 함수 (모든 하위 탭에 대해 한 번에 하나만 active)
   */
  function showStatsSubTab(subTabId, event) {
      // 모든 하위 탭 버튼과 컨텐츠 비활성화
      document.querySelectorAll('.stats-subtab-bar button').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.stats-subtab-content').forEach(content => content.classList.remove('active'));

      // null 체크 추가
      const subTabDiv = document.getElementById(subTabId);
      if (!subTabDiv) {
          console.error(`[showStatsSubTab] id="${subTabId}"인 div가 없습니다.`);
          return;
      }

      // 클릭된 하위 탭 버튼과 컨텐츠 활성화
      if (event && event.currentTarget) {
          event.currentTarget.classList.add('active');
      }
      subTabDiv.classList.add('active');

      // 각 하위 탭에 맞는 데이터 로드 함수를 *필요할 때만* 호출
      if (subTabId === 'goldPrice' && !goldPriceStatsLoaded) {
          loadGoldPriceForecast();
          goldPriceStatsLoaded = true;
      } else if (subTabId === 'orderTrends' && !orderTrendsLoaded) {
          loadOrderTrends();
          orderTrendsLoaded = true;
      } else if (subTabId === 'categoryProfit' && !categoryProfitLoaded) {
          loadCategoryProfit();
          categoryProfitLoaded = true;
      } else if (subTabId === 'demographics' && !demographicsLoaded) {
          loadDemographicsChart();
          demographicsLoaded = true;
      }
  }

  // --- 차트 로드 함수들 ---

  /**
   * 금 시세 예측 데이터 로드 및 그래프 그리기 함수
   */
  function loadGoldPriceForecast() {
      const loadingMsg = document.getElementById('loadingMessage');
      const plotDivs = ['forecastPlot', 'trendPlot', 'weeklyPlot'];

      loadingMsg.style.display = 'block';
      plotDivs.forEach(id => document.getElementById(id).style.display = 'none');

      fetch('/api/statistics/gold-price-forecast')
          .then(response => {
              if (!response.ok) throw new Error('서버 응답 오류: ' + response.statusText);
              return response.json();
          })
          .then(data => {
              if (data.error) throw new Error(data.error);

              loadingMsg.style.display = 'none';
              plotDivs.forEach(id => document.getElementById(id).style.display = 'block');

              // 예측 그래프
              const forecast = data.forecast;
              Plotly.newPlot('forecastPlot', [
                { x: forecast.ds, y: forecast.yhat_upper, mode: 'lines', line: { width: 0 }, showlegend: false },
                { x: forecast.ds, y: forecast.yhat_lower, mode: 'lines', line: { width: 0 }, fill: 'tonexty', fillcolor: 'rgba(0, 100, 255, 0.2)', showlegend: false },
                { x: forecast.ds, y: forecast.y, mode: 'markers', type: 'scatter', name: '실제 가격' },
                { x: forecast.ds, y: forecast.yhat, mode: 'lines', type: 'scatter', name: '예측 가격', line: { color: 'blue' } }
              ], { title: '향후 30일 금 시세 예측', xaxis: { title: '날짜' }, yaxis: { title: '가격 (원/g)' } });

              // 트렌드 그래프
              const trend = data.trend;
              Plotly.newPlot('trendPlot', [{ x: trend.ds, y: trend.y, mode: 'lines', type: 'scatter', name: '트렌드' }], { title: '시세 트렌드', xaxis: { title: '날짜' }, yaxis: { title: '트렌드 값' } });

              // 주간 계절성 그래프
              const weekly = data.weekly;
              Plotly.newPlot('weeklyPlot', [{ x: weekly.x, y: weekly.y, mode: 'lines', type: 'scatter', name: '주간 계절성' }], { title: '주간 계절성', xaxis: { title: '요일' }, yaxis: { title: '계절성 영향' } });
          })
          .catch(error => {
              console.error('Error fetching forecast data:', error);
              loadingMsg.innerText = '데이터를 불러오는 데 실패했습니다. \n오류: ' + error.message;
              loadingMsg.style.color = 'red';
          });
  }

  /**
   * 요일, 월별 트렌드 분석 데이터 로드 및 그래프 그리기 함수
   */
  function loadOrderTrends() {
      const loadingMsg = document.getElementById('orderTrendsLoading');
      const plotDivs = ['salesForecastPlot', 'salesWeeklyPlot', 'salesYearlyPlot'];

      loadingMsg.style.display = 'block';
      plotDivs.forEach(id => document.getElementById(id).style.display = 'none');

      fetch('/api/statistics/order-trends')
          .then(response => {
              if (!response.ok) throw new Error('서버 응답 오류: ' + response.statusText);
              return response.json();
          })
          .then(data => {
              if (data.error) throw new Error(data.error);

              loadingMsg.style.display = 'none';
              plotDivs.forEach(id => document.getElementById(id).style.display = 'block');

              // 1. 전체 매출 예측 그래프 (salesForecastPlot)
              const forecastData = data.main_forecast;
              Plotly.newPlot('salesForecastPlot', [
                  { x: forecastData.map(d => d.ds), y: forecastData.map(d => d.yhat_upper), mode: 'lines', line: { width: 0 }, showlegend: false },
                  { x: forecastData.map(d => d.ds), y: forecastData.map(d => d.yhat_lower), mode: 'lines', line: { width: 0 }, fill: 'tonexty', fillcolor: 'rgba(65, 105, 225, 0.2)', showlegend: false },
                  { x: forecastData.map(d => d.ds), y: forecastData.map(d => d.y), mode: 'markers', type: 'scatter', name: '실제 매출', marker: { color: 'black', size: 4 } },
                  { x: forecastData.map(d => d.ds), y: forecastData.map(d => d.yhat), mode: 'lines', type: 'scatter', name: '예측 매출', line: { color: 'royalblue' } }
              ], { title: '총 매출 예측 (향후 90일)', xaxis: { title: '날짜' }, yaxis: { title: '매출액 (원)', tickformat: ',.0f' } });

              // 2. 요일별 매출 트렌드 그래프 (salesWeeklyPlot)
              const weeklyData = data.weekly_seasonality;
              Plotly.newPlot('salesWeeklyPlot', [{
                  x: weeklyData.map(d => d.day_name),
                  y: weeklyData.map(d => d.weekly_effect),
                  type: 'bar',
                  name: '요일별 효과',
                  marker: { color: weeklyData.map(d => d.weekly_effect > 0 ? 'crimson' : 'royalblue') }
              }], { title: '요일별 매출 트렌드', xaxis: { title: '요일' }, yaxis: { title: '매출 증감 효과 (원)', tickformat: ',.0f' } });

              // 3. 월별 매출 트렌드 그래프 (salesYearlyPlot)
              const yearlyData = data.yearly_seasonality;
              Plotly.newPlot('salesYearlyPlot', [{
                  x: yearlyData.map(d => d.month_name),
                  y: yearlyData.map(d => d.yearly_effect),
                  mode: 'lines+markers',
                  type: 'scatter',
                  name: '월별 효과'
              }], { title: '월별 매출 트렌드', xaxis: { title: '월' }, yaxis: { title: '매출 증감 효과 (원)', tickformat: ',.0f' } });
          })
          .catch(error => {
              console.error('Error fetching order trends data:', error);
              loadingMsg.innerText = '데이터를 불러오는 데 실패했습니다. \n오류: ' + error.message;
              loadingMsg.style.color = 'red';
          });
  }

  // 카테고리별 이익률 분석 및 예측 데이터 로드 및 그래프 그리기 함수
  function loadCategoryProfit() {
      const plotDiv = document.getElementById("categoryProfitPlot");
      const loadingDiv = document.getElementById("categoryProfitLoading");
      if (!plotDiv || !loadingDiv) {
          console.error("[categoryProfit] 필요한 div가 없습니다.");
          return;
      }
      plotDiv.style.display = "none";
      loadingDiv.style.display = "block";

      fetch('/api/statistics/category-profit')
          .then(res => res.json())
          .then(data => {
              if (!data || !data.monthly || !data.forecast) {
                  loadingDiv.innerText = "데이터가 없습니다.";
                  return;
              }
              const months = data.monthly.map(item => item.Month);
              const margins = data.monthly.map(item => item.Profit_Margin);
              const forecast = data.forecast;

              loadingDiv.style.display = "none";
             

              Plotly.newPlot("categoryProfitPlot", [
                  {
                      x: months,
                      y: margins,
                      mode: 'lines+markers',
                      name: '이익률',
                      line: { color: 'green' }
                  },
                  {
                      x: [forecast.month],
                      y: [forecast.predicted_margin],
                      mode: 'markers+text',
                      name: '예측값',
                      marker: { size: 10, color: 'red' },
                      text: ['예측'],
                      textposition: 'top center'
                  }
              ], {
                  title: '카테고리별 이익률 분석 및 7월 예측',
                  xaxis: { title: '월' },
                  yaxis: { title: '이익률' }
              });
          })
          .catch(err => {
              loadingDiv.innerText = "데이터 로딩 중 오류가 발생했습니다.";
              console.error('이익률 분석 불러오기 실패:', err);
          });
  }

  // 성별/연령대별 차트 (탭 클릭 시에만 로드)
  function loadDemographicsChart() {
    const loadingDiv = document.getElementById("sexAgeLoading");
    const plotDivMale = document.getElementById("genderAgeChartPlotMale");
    const plotDivFemale = document.getElementById("genderAgeChartPlotFemale");
    if (!loadingDiv || !plotDivMale || !plotDivFemale) {
      console.error("[성별/연령대] 필요한 div가 없습니다.");
      return;
    }
    fetch("/temp_output.json")
      .then(response => response.json())
      .then(data => {
        if (!data || !data.male || !data.female) {
          loadingDiv.innerText = "데이터가 없습니다.";
          return;
        }
        const maleData = data.male;
        const femaleData = data.female;

        const ageGroups = [...new Set([...maleData, ...femaleData].map(d => d.Age_Group))];
        const categories = [...new Set([...maleData, ...femaleData].map(d => d.Category))];

        // 🔹 남성 데이터 시리즈 생성
        const maleSeries = categories.map(category => {
          return {
            x: ageGroups,
            y: ageGroups.map(ageGroup => {
              const item = maleData.find(d => d.Age_Group === ageGroup && d.Category === category);
              return item ? item.Total_Price : 0;
            }),
            name: `${category}`,
            type: 'bar'
          };
        });

        // 🔹 여성 데이터 시리즈 생성
        const femaleSeries = categories.map(category => {
          return {
            x: ageGroups,
            y: ageGroups.map(ageGroup => {
              const item = femaleData.find(d => d.Age_Group === ageGroup && d.Category === category);
              return item ? item.Total_Price : 0;
            }),
            name: `${category}`,
            type: 'bar'
          };
        });

        // 🔹 공통 레이아웃
        const baseLayout = {
          barmode: 'group',
          xaxis: { title: '연령대' },
          yaxis: { title: '총 매출 (원)' },
          legend: { orientation: 'h' },
          height: 450
        };

        // 🔹 남성/여성 각각의 차트로 나란히 출력
        Plotly.newPlot("genderAgeChartPlotMale", maleSeries, {
          ...baseLayout,
          title: '👨 남성 연령대별 · 카테고리별 매출'
        });
        Plotly.newPlot("genderAgeChartPlotFemale", femaleSeries, {
          ...baseLayout,
          title: '👩 여성 연령대별 · 카테고리별 매출'
        });

        // 🔹 로딩 메시지 숨기기
        loadingDiv.style.display = "none";
      })
      .catch(error => {
        loadingDiv.innerText = "데이터 로딩 중 오류가 발생했습니다.";
        console.error("❌ JSON 로딩 오류:", error);
      });
  }
</script>

  <script> // 영업이익률 차트
    function showStatsSubTab(subTabId, event) {
        document.querySelectorAll('.stats-subtab-bar button').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.stats-subtab-content').forEach(content => content.classList.remove('active'));

        // null 체크 추가
        const subTabDiv = document.getElementById(subTabId);
        if (!subTabDiv) {
            console.error(`[showStatsSubTab] id="${subTabId}"인 div가 없습니다.`);
            return;
        }

        if (event && event.currentTarget) {
            event.currentTarget.classList.add('active');
        }
        subTabDiv.classList.add('active');

        // ✅ 이익률 데이터 불러오기
        if (subTabId === 'categoryProfit') {
            loadCategoryProfit();
        }
    }

    function loadCategoryProfit() {
        const plotDiv = document.getElementById("categoryProfitPlot");
        const loadingDiv = document.getElementById("categoryProfitLoading");
        if (!plotDiv || !loadingDiv) {
            console.error("[categoryProfit] 필요한 div가 없습니다.");
            return;
        }
        plotDiv.style.display = "none";
        loadingDiv.style.display = "block";

        fetch('/api/statistics/category-profit')
            .then(res => res.json())
            .then(data => {
                if (!data || !data.monthly || !data.forecast) {
                    loadingDiv.innerText = "데이터가 없습니다.";
                    return;
                }
                const months = data.monthly.map(item => item.Month);
                const margins = data.monthly.map(item => item.Profit_Margin);
                const forecast = data.forecast;

                loadingDiv.style.display = "none";
                plotDiv.style.display = "block";

                Plotly.newPlot("categoryProfitPlot", [
                    {
                        x: months,
                        y: margins,
                        mode: 'lines+markers',
                        name: '이익률',
                        line: { color: 'green' }
                    },
                    {
                        x: [forecast.month],
                        y: [forecast.predicted_margin],
                        mode: 'markers+text',
                        name: '예측값',
                        marker: { size: 10, color: 'red' },
                        text: ['예측'],
                        textposition: 'top center'
                    }
                ], {
                    title: '카테고리별 이익률 분석 및 7월 예측',
                    xaxis: { title: '월' },
                    yaxis: { title: '이익률' }
                });
            })
            .catch(err => {
                loadingDiv.innerText = "데이터 로딩 중 오류가 발생했습니다.";
                console.error('이익률 분석 불러오기 실패:', err);
            });
    }
  </script>

  <script>//성별 연령별 분석
    document.addEventListener("DOMContentLoaded", function () {
      const loadingDiv = document.getElementById("sexAgeLoading");
      const plotDivMale = document.getElementById("genderAgeChartPlotMale");
      const plotDivFemale = document.getElementById("genderAgeChartPlotFemale");
      if (!loadingDiv || !plotDivMale || !plotDivFemale) {
        console.error("[성별/연령대] 필요한 div가 없습니다.");
        return;
      }
      fetch("/temp_output.json")
        .then(response => response.json())
        .then(data => {
          if (!data || !data.male || !data.female) {
            loadingDiv.innerText = "데이터가 없습니다.";
            return;
          }
          const maleData = data.male;
          const femaleData = data.female;

          const ageGroups = [...new Set([...maleData, ...femaleData].map(d => d.Age_Group))];
          const categories = [...new Set([...maleData, ...femaleData].map(d => d.Category))];

          // 🔹 남성 데이터 시리즈 생성
          const maleSeries = categories.map(category => {
            return {
              x: ageGroups,
              y: ageGroups.map(ageGroup => {
                const item = maleData.find(d => d.Age_Group === ageGroup && d.Category === category);
                return item ? item.Total_Price : 0;
              }),
              name: `${category}`,
              type: 'bar'
            };
          });

          // 🔹 여성 데이터 시리즈 생성
          const femaleSeries = categories.map(category => {
            return {
              x: ageGroups,
              y: ageGroups.map(ageGroup => {
                const item = femaleData.find(d => d.Age_Group === ageGroup && d.Category === category);
                return item ? item.Total_Price : 0;
              }),
              name: `${category}`,
              type: 'bar'
            };
          });

          // 🔹 공통 레이아웃
          const baseLayout = {
            barmode: 'group',
            xaxis: { title: '연령대' },
            yaxis: { title: '총 매출 (원)' },
            legend: { orientation: 'h' },
            height: 450
          };

          // 🔹 남성/여성 series를 모두 합쳐서 한 번에 그리기
          const allSeries = [
            ...maleSeries.map(s => ({ ...s, name: '남성-' + s.name })),
            ...femaleSeries.map(s => ({ ...s, name: '여성-' + s.name }))
          ];

          // 🔹 남성/여성 각각의 차트로 나란히 출력
          Plotly.newPlot("genderAgeChartPlotMale", maleSeries, {
            ...baseLayout,
            title: '👨 남성 연령대별 · 카테고리별 매출'
          });
          Plotly.newPlot("genderAgeChartPlotFemale", femaleSeries, {
            ...baseLayout,
            title: '👩 여성 연령대별 · 카테고리별 매출'
          });

          // 🔹 로딩 메시지 숨기고 차트 보여주기
          loadingDiv.style.display = "none";
        })
        .catch(error => {
          loadingDiv.innerText = "데이터 로딩 중 오류가 발생했습니다.";
          console.error("❌ JSON 로딩 오류:", error);
        });
    });
  </script>




</body>
</html>
